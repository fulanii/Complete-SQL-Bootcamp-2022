``` sql 
SECTION 8 Creating Databases and Tables

1. Data types:  are just different types of data in SQL ex: bellow

Most Common Data Types

- Boolean: True or False
- Character: char, varchar, and text
- Numeric: integer and floating-point number
- Temporal: date, time, timestamp, and interval

Not as common Data Types

- UUID: universally unique identifiers
- Array: stores an array of strings, numbers etc ( like a python list )
- JSON:
- Hstore: store key value pair ( like a python dictionanry )
- Special types such as network address and geometric data

When creating databases and tables u should carefully consider which data types should be used for the data to be stored.

Always review documentation to see the data types limitation

[https://www.postgresql.org/docs/current/datatype.html](https://www.postgresql.org/docs/current/datatype.html)

When creating database and table, take your time to plan for long term storage Remember you can always remove historical information you've decided you aren't using, but you can't go back in time to add in information!

1. Primary Keys and Foreign Keys

Primary Keys: is a column or group of columns used to identify a row uniquely in a table

Ex: in the dvdrental database we have a unique, non-null customer_id column as the primary key. Unique mean it has to be distinct for every row and non-null mean there must be an entry and cant be empty.

Foreign Keys: is a field or group of fields in a table that uniquely identifies a row in another table.

A foreign key is defined in a table that references to the primary key of the other table.

The table that contains the foreign key is called referencing table or child table.
The table to which the foreign key references is called referenced table or parent table.
A table can have multiple foreign keys depending on its relationships with other tables.

1. Constraints: are like rules enforced on the data columns on table, these are used to prevent invalid data from being entered into our database. And it ensure accuracy and reliability of the database.

Contraints can be divided into two main categories 

1. Column Contraints
    - contrains the data in a column to adhere to certain conditions
2. Table Constraints
    - applied to the entire table rather than to an individual column

Ex of most common contraints used 

- NOT NULL constraint: ensures that a column cannot have a null value
- UNIQUE contraints: ensures that all values in a column are different/unique
- Primary Key Constrains uniquely identifies each row/record in a database table.
- Foreign Key Constrains data based on columns in other tables.
- Check Contraint ensures that all values in a column satisfy certain conditions
- Exclusion Constraint ( Look up)

---

CREATE TABLE: keyword allows u to creates tables in SQL

```sql
-- Full general syntax
CREATE TABLE table_name (
	column_name TYPE column_constraint,
	column_name TYPE column_constraint,
	table_constraint table_constraint
) INHERITS existing_table_name

-- real syntax example
CREATE TABLE player (
	player_id SERIAL PRIMARY KEY -- see serial def bellow 
	age SMALLINT NOT NULL 
)
```

SERIAL:  in postgreSQL a sequence is a special kind of databse object that generates a sequence of integers and a sequence is often used as the primary key column in a table. 

so serial will create a sequence object and set the next value generated by the sequence as the default value for the column. This is perfect for a primary key because it logs unique entries for you automatically upon insertion

If arow is later removed, the column with the SERIAL data type will not adjust, marking the fact that a row was removed from the sequence, for example 1,2,3,5,6,7
You know row 4 was removed at some point

```sql
-- query used to create account table
CREATE TABLE account(
    user_id SERIAL PRIMARY KEY,
    user_name VARCHAR (50) UNIQUE NOT NULL,
    password VARCHAR (50) NOT NULL,
    email VARCHAR (250) UNIQUE NOT NULL,
    creat_on TIMESTAMP NOT NULL,
    last_login TIMESTAMP
)
-- 
```

---

INSERT: allows you to add in rows to a table 

```sql
-- general syntax
INSERT INTO tableName(column1, column2,...)
VALUES
	(value1, value2,...)
	( value1, value2,...)  

-- real life syntax ex
INSERT INTO account(user_name, password, email, creat_on)
VALUES
('Yassine', 'password', 'yassine@yassine.com', CURRENT_TIMESTAMP)
-- above we where it says account(columns...) we pass in all the columns
-- we want to fill out in that order so the values have to be in order too

-- notice how we didn't add user_id column that's coz it's fill out automaticalyy
-- by postgreSQL since we set it to SERIAL
-- dont forget the commas , its v important

-- table that references multiple tables (intermidiary table)
CREATE TABLE account_job(
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
)
-- notice how for user_id we set it to INTEGER and not SERIAL that's coz it's
-- referencing a foreing_key to another table 

-- (only use SERIAL for primary key in its table) 
-- (use INTEGER to refer to the primary key from another table)

-- u cant add a user_id to the account_job table that doesn't exist 
-- in the account table... why u ask?

-- coz the user_id from account_job table is referring to 
-- the user_id from the account table it

-- ^^ same for the job_id 
```

```sql
-- general syntax
INSERT INTO tableName(column1, column2,...)
VALUES
	(value1, value2,...)
	( value1, value2,...)  

-- real life syntax ex
INSERT INTO account(user_name, password, email, creat_on)
VALUES
('Yassine', 'password', 'yassine@yassine.com', CURRENT_TIMESTAMP)
-- above we where it says account(columns...) we pass in all the columns
-- we want to fill out in that order so the values have to be in order too

-- notice how we didn't add user_id column that's coz it's fill out automaticalyy
-- by postgreSQL since we set it to SERIAL
-- dont forget the commas , its v important

-- table that references multiple tables (intermidiary table)
CREATE TABLE account_job(
	user_id INTEGER REFERENCES account(user_id),
	job_id INTEGER REFERENCES job(job_id),
	hire_date TIMESTAMP
)
-- notice how for user_id we set it to INTEGER and not SERIAL that's coz it's
-- referencing a foreing_key to another table 

-- (only use SERIAL for primary key in its table) 
-- (use INTEGER to refer to the primary key from another table)

-- u cant add a user_id to the account_job table that doesn't exist 
-- in the account table... why u ask?

-- coz the user_id from account_job table is referring to 
-- the user_id from the account table it

-- ^^ same for the job_id 
```

---

UPDATE: keyword allows for the changing of the values of the column in a table

```sql
-- general syntax
UPDATE table 
SET column1 = value1
column2 = value2
WHERE condition

-- reset everything without condition
UPDATE account 
SET last_login = CURRENT_TIMESTAMP

-- set based on another column
UPDATE account
SET last_login = created_on

-- using another table values (update join)
UPDATE tableA 
SET original_col = tableB.new_col
FROM tableB
WHERE tableA.id = tableB.id 

-- return rows that were affected
UPDATE account SET last_login = created_on
RETURNING account_id, lasr_login
```

```sql
-- real life symtax ex:

UPDATE account
SET last_login = CURRENT_TIMESTAMP
-- this querry will set the the last login column to the current time date etc

UPDATE account
SET last_login = creat_on 
-- this query will set last_login to what creat_on is to

SET last_login = '2022-01-01'
WHERE last_login IS NULL
-- this query uses a condition to update the last_login column
-- only where last_login is NULL

UPDATE account_job
SET hire_date = account.creat_on
FROM account
-- this is call an update join this query uses a different table to update a 
-- column or using the condition like WHERE to specify a row or rows 
-- to update that matches the condition 

UPDATE account_job
SET hire_date = CURRENT_TIMESTAMP
RETURNING *
-- using the returning keyword u can return specific columns or all of them
-- after updating in 1 query so u dont have to type select again 

-- update multiple rows using CASE 
-- (btw using this will lose every rown in the column being updated that's not 
-- part of the update bellow) 
UPDATE table_test 
SET address = CASE
    when id = 3 then '512 marker dr'
    when id = 2 then '615 thusk rd'
END
```

---

DELETE: We can use the delete clause to remove rows from a table 

```sql
-- general syntax
DELETE FROM tableName
WHERE row_id = 1

-- delete based on other tables
DELETE FROM tableA
USING tableB
WHERE tableA.id = tableB.id

-- delete everything from a table
DELETE FROM tableName

-- u can also add the returning clause to see what got delete

-- this query will delete the job mag row and return everything that got 
-- deleted in that row
DELETE FROM job
WHERE job_name = 'mag'
RETURNING *
```

---

ALTER :  allows to make change to an existing table ex of some bellow:

- Adding, dropping, or renaming columns
- Changing a column's data type
- Set DEFAULT values for a column
- Add CHECK constraints
- Rename table

```sql
-- general syntax
ALTER TABLE tableName action 
-- (replace action with what you wanna change in the table )

-- add column 
ALTER TABLE tableName ADD COLUMN new_colName TYPE
-- this how u add a new column to a table give it a name and data type

-- removing columns 
ALTER TABLE tableName DROP COLUMN colName
-- this query will remove a column from a table

-- u can even alter the constraints
ALTER TABLE tableName ALTER COLUMN colName 
-- list bellow of some contraint u can alter 
SET DEFAULT value
DROP DEFAULT 
SET NOT NULL
DROP NOT NULL
ADD CONSTRAINT constraint_name

-- remaing a table
ALTER TABLE account
RENAME TO k
-- here the account table will be remane to k

-- renaming a colum
ALTER TABLE account
RENAME COLUMN creat_on
TO created_on
-- this query will rename the creat_on column 
-- from the account table to created_on
 

-- https://www.postgresql.org/docs/current/sql-altertable.html
```

---

DROP: allows to complete remove a column in a table 

```sql
-- general syntax
ALTER TABLE table_name
DROP COLUMN columnName

-- if exist
ALTER TABLE table_name
DROP COLUMN IF EXISTS columnName
-- by adding if exists postgresql will only try to drop the column if it exists
-- and it it doesnt exists u wont get an error 

-- Drop multiple table
ALTER TABLE table_name
DROP COLUMN columnName1,
DROP COLUMN columnName2,
DROP COLUMN columnName3,
```

---

CHECK: constraint allows to create more customized constraints that adhere to a certain conditions.

```sql
-- general syntax
CREATE TABLE example(

	  id SERIAL PRIMARY KEY,
    age SMALLINT CHECK(age > 21),
    parent_age SMALLINT CHECK(parent_age > age) 
   
);
-- so how check constraints works is it basically check 
-- whatever u ask it to check before inserting anything in the column
-- with check constraints

-- ex above u can't insert any age bellow 21 coz of the check constraints
-- and u cant insert a parent age that isn't grater than 21 

```

---

